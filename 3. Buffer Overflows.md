In this part, you want to trigger the part of the code that allows you to write to the terminal.
But to do that, your key has to be set to a certain value, but you don't get to input anything
and the key value is already set. But you do get to input something into the buffer.

So we can use the buffer which uses the gets() command to fill it which doesn't protect against
buffer overflows. Variables are put in the stack in a way that earlier variables are last in the
memory because it grows upwards. So if the local variable key is in memory after the buffer,
then we can keep writing to the buffer to overwrite the key with the correct one. Some of the
commands below are helpful in doing so.

1. Check the files architecture first
```
file ./binary_name
```

2. Extract useful symbols
```
nm ./binary_name
```

3. Disassemble the binary
objdump -d ./binary_name > disassembly.txt


4. In our case we are looking for the address of specific functions so we can use grep to search 
   for their addresses with the following
```
readelf -s ./binary_name | grep <function name>
```

5. It is a 32 bit file so you can't run it  without installing some libraries first.
```
apt-get install libc6-i386
```
6. Inside of gdb you can also do the following commands to get the assembly
```
disas main

disas func
```

Since our main calls function with the incorrect key as a parameter, we want to use the disassembly
to find where that is so we can potentially change it.